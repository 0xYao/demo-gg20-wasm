//! Webassembly utilities for the threshold signatures snap.
#![deny(missing_docs)]
use thiserror::Error;
use sha3::{Keccak256, Digest};
use std::convert::TryInto;
use wasm_bindgen::prelude::*;

extern crate wasm_bindgen;

#[wasm_bindgen]
extern "C" {
    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &str);
}

#[doc(hidden)]
#[macro_export]
macro_rules! console_log {
    ($($t:tt)*) => (log(&format_args!($($t)*).to_string()))
}

mod xchacha20poly1305;

/// Error thrown by the library.
#[derive(Debug, Error)]
pub enum Error {
    /// Error generated ecnrypting or decrypting.
    #[error(transparent)]
    Aead(#[from] chacha20poly1305::aead::Error),
}

/// Encrypt a buffer of unsigned 8-bit integers using the given key.
///
/// The key is the base64-encoded data returned from `snap_getBip44Entropy_60`
/// which will be hashed using `keccak256` to generate the 32 byte private key
/// needed for for the XChaCha20Poly1305 encryption.
#[wasm_bindgen]
pub fn encrypt(key: JsValue, buffer: JsValue) -> Result<JsValue, JsError> {
    let key: String = key.into_serde()?;
    let key = Keccak256::digest(&key);
    let key: [u8; 32] = key.as_slice().try_into()?;
    let buffer: Vec<u8> = buffer.into_serde()?;
    let aead_pack = xchacha20poly1305::encrypt(&key, &buffer)?;
    Ok(JsValue::from_serde(&aead_pack)?)
}

/// Decrypt an AeadPack generated by encrypt using the given key.
///
/// The key is the base64-encoded data returned from `snap_getBip44Entropy_60`
/// which will be hashed using `keccak256` to generate the 32 byte private key
/// needed for for the XChaCha20Poly1305 decryption.
#[wasm_bindgen]
pub fn decrypt(key: JsValue, aead_pack: JsValue) -> Result<JsValue, JsError> {
    let key: String = key.into_serde()?;
    let key = Keccak256::digest(&key);
    let key: [u8; 32] = key.as_slice().try_into()?;
    let aead_pack: xchacha20poly1305::AeadPack = aead_pack.into_serde()?;
    let buffer = xchacha20poly1305::decrypt(&key, &aead_pack)?;
    Ok(JsValue::from_serde(&buffer)?)
}
