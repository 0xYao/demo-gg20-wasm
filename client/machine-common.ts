import { State } from "./state-machine";

// Configuration parameters retrieved from the server
// during the handshake.
export interface Parameters {
  parties: number;
  threshold: number;
}

// Opaque type for the final generated key data,
// see the rust `PartyKey` type for details.
export interface PartyKey {}

// The result from generating a key.
export interface KeygenResult {
  parameters: Parameters;
  key: PartyKey;
}

// Generated by the server to signal this party wants
// to be included in key generation.
export interface PartySignup {
  number: number;
  uuid: string;
}

// Opaque type proxied from WASM to the server
export interface Entry {
  key: string;
  value: string;
}

// Temporary object passed back and forth between javascript
// and webassembly for the various rounds.
export interface RoundEntry {
  entry: Entry;
  // Webassembly adds a bunch of temporary properties
  // to each round entry for further rounds but
  // these fields should not be accessed here
  // however we declare their presence in the type
  [x: string]: any;
}

// Type received from the server once all parties have commited
// to a round; contains the answers from the other parties.
export interface BroadcastAnswer {
  answer: string[];
}

// PeerEntry is sent by the server when relaying messages
// peer to peer during round 3 of key generation.
export interface PeerEntry {
  party_from: number;
  party_to: number;
  entry: Entry;
}

// Temporary state for caching peer entries during round 3
// of the key generation.
export interface PeerState {
  parties: number;
  received: PeerEntry[];
}

// Holds the websocket identifier.
export interface ClientId {
  conn_id: number;
}

// Encapsulates server handshake information.
export interface Handshake {
  client: ClientId;
  parameters: Parameters;
}

export function getSortedPeerEntriesAnswer(peerState: PeerState): string[] {
  // Must sort the entries otherwise the decryption
  // keys will not match the peer entries
  peerState.received.sort((a: PeerEntry, b: PeerEntry) => {
    if (a.party_from < b.party_from) return -1;
    if (a.party_from > b.party_from) return 1;
    return 0;
  });
  return peerState.received.map((peer: PeerEntry) => peer.entry.value);
}

export function makeOnTransition<T, U>(postMessage: Function) {
  return (
    index: number,
    previousState: State<T, U>,
    nextState: State<T, U>
  ) => {
    let message = "";
    if (previousState) {
      message = `transition ${index} from ${previousState.name} to ${nextState.name}`;
    } else {
      message = `transition ${index} to ${nextState.name}`;
    }
    console.log(message);
    postMessage({ type: "log", message });
  };
}
